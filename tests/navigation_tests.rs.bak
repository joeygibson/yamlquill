//! Tests for navigation enhancements (Phase 2f)
//!
//! Validates navigation commands:
//! - Sibling navigation with [ and ]
//! - Jump to parent with gp
//! - Fold commands: za, zM, zR, zc

use yamlquill::document::node::{YamlNode, YamlNumber, YamlString, YamlValue};
use yamlquill::document::tree::YamlTree;
use yamlquill::editor::state::EditorState;
use indexmap::IndexMap;

/// Creates a nested tree for navigation testing
fn create_nested_tree() -> YamlTree {
    // Create structure:
    // {
    //   "first": "value1",
    //   "second": {
    //     "nested": "value2"
    //   },
    //   "third": [42, 43, 44]
    // }
    let mut obj = IndexMap::new();
    obj.insert(
        "first".to_string(),
        YamlNode::new(YamlValue::String(YamlString::Plain("value1".to_string()))),
    );

    let mut nested_obj = IndexMap::new();
    nested_obj.insert(
        "nested".to_string(),
        YamlNode::new(YamlValue::String(YamlString::Plain("value2".to_string()))),
    );
    obj.insert(
        "second".to_string(),
        YamlNode::new(YamlValue::Object(nested_obj)),
    );

    let array = vec![
        YamlNode::new(YamlValue::Number(YamlNumber::Integer(42))),
        YamlNode::new(YamlValue::Number(YamlNumber::Integer(43))),
        YamlNode::new(YamlValue::Number(YamlNumber::Integer(44))),
    ];
    obj.insert("third".to_string(), YamlNode::new(YamlValue::Array(array)));

    YamlTree::new(YamlNode::new(YamlValue::Object(obj)))
}

#[test]
fn test_next_sibling_navigation() {
    let tree = create_nested_tree();
    let mut state = EditorState::new_with_default_theme(tree);

    // Start at first key (index 0)
    state.cursor_mut().set_path(vec![0]);

    // Move to next sibling
    state.move_to_next_sibling();

    // Should be at second key (index 1)
    assert_eq!(state.cursor().path(), &[1]);
}

#[test]
fn test_previous_sibling_navigation() {
    let tree = create_nested_tree();
    let mut state = EditorState::new_with_default_theme(tree);

    // Start at second key (index 1)
    state.cursor_mut().set_path(vec![1]);

    // Move to previous sibling
    state.move_to_previous_sibling();

    // Should be at first key (index 0)
    assert_eq!(state.cursor().path(), &[0]);
}

#[test]
fn test_move_to_parent() {
    let tree = create_nested_tree();
    let mut state = EditorState::new_with_default_theme(tree);

    // Navigate to nested value at path [1, 0] (second -> nested)
    state.cursor_mut().set_path(vec![1, 0]);

    // Move to parent
    state.move_to_parent();

    // Should be at second object (path [1])
    assert_eq!(state.cursor().path(), &[1]);
}

#[test]
fn test_toggle_expand() {
    let tree = create_nested_tree();
    let mut state = EditorState::new_with_default_theme(tree);

    // Navigate to second object (expandable)
    state.cursor_mut().set_path(vec![1]);

    // Initially should be expanded (or not, depends on default)
    let initial_expanded = state.tree_view_state().is_expanded(&[1]);

    // Toggle expand
    state.toggle_expand_at_cursor();

    // Should be opposite of initial state
    assert_eq!(
        state.tree_view_state().is_expanded(&[1]),
        !initial_expanded
    );

    // Toggle again
    state.toggle_expand_at_cursor();

    // Should be back to initial state
    assert_eq!(
        state.tree_view_state().is_expanded(&[1]),
        initial_expanded
    );
}

#[test]
fn test_expand_all_at_cursor() {
    let tree = create_nested_tree();
    let mut state = EditorState::new_with_default_theme(tree);

    // Collapse everything first
    state.cursor_mut().set_path(vec![1]);
    state.collapse_all_at_cursor();

    // Verify collapsed
    assert!(!state.tree_view_state().is_expanded(&[1]));

    // Expand all at cursor
    state.expand_all_at_cursor();

    // Should be expanded
    assert!(state.tree_view_state().is_expanded(&[1]));
}

#[test]
fn test_collapse_all_at_cursor() {
    let tree = create_nested_tree();
    let mut state = EditorState::new_with_default_theme(tree);

    // Expand everything first
    state.cursor_mut().set_path(vec![1]);
    state.expand_all_at_cursor();

    // Verify expanded
    assert!(state.tree_view_state().is_expanded(&[1]));

    // Collapse all at cursor
    state.collapse_all_at_cursor();

    // Should be collapsed
    assert!(!state.tree_view_state().is_expanded(&[1]));
}

#[test]
fn test_sibling_navigation_in_array() {
    let tree = create_nested_tree();
    let mut state = EditorState::new_with_default_theme(tree);

    // Navigate to third key (array)
    state.cursor_mut().set_path(vec![2]);

    // Expand it to see array elements
    state.expand_all_at_cursor();

    // Navigate to first array element
    state.cursor_mut().set_path(vec![2, 0]);

    // Move to next sibling (second array element)
    state.move_to_next_sibling();

    // Should be at [2, 1]
    assert_eq!(state.cursor().path(), &[2, 1]);

    // Move to previous sibling
    state.move_to_previous_sibling();

    // Should be back at [2, 0]
    assert_eq!(state.cursor().path(), &[2, 0]);
}

#[test]
fn test_move_to_parent_from_array_element() {
    let tree = create_nested_tree();
    let mut state = EditorState::new_with_default_theme(tree);

    // Navigate to array element at [2, 1]
    state.cursor_mut().set_path(vec![2, 1]);

    // Move to parent (the array)
    state.move_to_parent();

    // Should be at [2]
    assert_eq!(state.cursor().path(), &[2]);
}

#[test]
fn test_first_sibling_navigation() {
    let tree = create_nested_tree();
    let mut state = EditorState::new_with_default_theme(tree);

    // Start at third key (index 2)
    state.cursor_mut().set_path(vec![2]);

    // Move to first sibling
    state.move_to_first_sibling();

    // Should be at first key (index 0)
    assert_eq!(state.cursor().path(), &[0]);
}

#[test]
fn test_last_sibling_navigation() {
    let tree = create_nested_tree();
    let mut state = EditorState::new_with_default_theme(tree);

    // Start at first key (index 0)
    state.cursor_mut().set_path(vec![0]);

    // Move to last sibling
    state.move_to_last_sibling();

    // Should be at third key (index 2)
    assert_eq!(state.cursor().path(), &[2]);
}
