#!/usr/bin/env bash
# Version management script for jsonquill

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Function to get current version from Cargo.toml
get_version() {
    grep '^version = ' Cargo.toml | head -n 1 | sed 's/version = "\(.*\)"/\1/'
}

# Function to validate version format (X.Y.Z)
validate_version() {
    local version=$1
    if ! [[ $version =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
        echo -e "${RED}Error: Invalid version format. Must be X.Y.Z (e.g., 1.2.3)${NC}" >&2
        exit 1
    fi
}

# Function to update version in Cargo.toml
update_version() {
    local new_version=$1
    local current_version=$(get_version)

    # Update version in Cargo.toml
    sed -i.bak "s/^version = \"$current_version\"/version = \"$new_version\"/" Cargo.toml
    rm Cargo.toml.bak

    echo -e "${GREEN}Updated Cargo.toml: $current_version â†’ $new_version${NC}"
}

# Function to generate release notes from git commits
generate_release_notes() {
    local current_version=$1
    local prev_tag="v$current_version"

    # Try to find the previous tag
    if ! git rev-parse "$prev_tag" >/dev/null 2>&1; then
        echo -e "${YELLOW}No previous tag found, using all commits${NC}" >&2
        prev_tag=""
    fi

    # Get commits since last version
    local commits
    if [ -n "$prev_tag" ]; then
        commits=$(git log --pretty=format:"%h %s" "$prev_tag..HEAD" 2>/dev/null)
    else
        commits=$(git log --pretty=format:"%h %s" 2>/dev/null)
    fi

    # Parse commits into categories
    local added=()
    local changed=()
    local fixed=()
    local other=()

    while IFS= read -r commit; do
        [ -z "$commit" ] && continue

        local hash=$(echo "$commit" | awk '{print $1}')
        local msg=$(echo "$commit" | cut -d' ' -f2-)

        # Parse conventional commit format
        if [[ $msg =~ ^feat(\(.*\))?: ]]; then
            local description=$(echo "$msg" | sed 's/^feat(\(.*\)): //' | sed 's/^feat: //')
            added+=("$description")
        elif [[ $msg =~ ^fix(\(.*\))?: ]]; then
            local description=$(echo "$msg" | sed 's/^fix(\(.*\)): //' | sed 's/^fix: //')
            fixed+=("$description")
        elif [[ $msg =~ ^docs(\(.*\))?: ]]; then
            local description=$(echo "$msg" | sed 's/^docs(\(.*\)): //' | sed 's/^docs: //')
            changed+=("Documentation: $description")
        elif [[ $msg =~ ^refactor(\(.*\))?: ]]; then
            local description=$(echo "$msg" | sed 's/^refactor(\(.*\)): //' | sed 's/^refactor: //')
            changed+=("$description")
        elif [[ $msg =~ ^perf(\(.*\))?: ]]; then
            local description=$(echo "$msg" | sed 's/^perf(\(.*\)): //' | sed 's/^perf: //')
            changed+=("Performance: $description")
        elif [[ $msg =~ ^test(\(.*\))?: ]]; then
            local description=$(echo "$msg" | sed 's/^test(\(.*\)): //' | sed 's/^test: //')
            other+=("Testing: $description")
        elif [[ $msg =~ ^chore(\(.*\))?: ]]; then
            # Skip chore commits (version bumps, formatting, etc.)
            continue
        else
            # Non-conventional commits
            other+=("$msg")
        fi
    done <<< "$commits"

    # Build the changelog entry
    local entry=""

    if [ ${#added[@]} -gt 0 ]; then
        entry+="### Added\n\n"
        for item in "${added[@]}"; do
            entry+="- $item\n"
        done
        entry+="\n"
    fi

    if [ ${#changed[@]} -gt 0 ]; then
        entry+="### Changed\n\n"
        for item in "${changed[@]}"; do
            entry+="- $item\n"
        done
        entry+="\n"
    fi

    if [ ${#fixed[@]} -gt 0 ]; then
        entry+="### Fixed\n\n"
        for item in "${fixed[@]}"; do
            entry+="- $item\n"
        done
        entry+="\n"
    fi

    if [ ${#other[@]} -gt 0 ]; then
        entry+="### Other\n\n"
        for item in "${other[@]}"; do
            entry+="- $item\n"
        done
        entry+="\n"
    fi

    # If no categorized changes, add a placeholder
    if [ -z "$entry" ]; then
        entry="### Changed\n\n- Minor updates and improvements\n\n"
    fi

    echo -e "$entry"
}

# Function to generate GitHub release notes
generate_github_release_notes() {
    local new_version=$1
    local current_version=$2
    local date=$(date +"%B %d, %Y")

    # Try to find the previous tag
    local prev_tag="v$current_version"
    if ! git rev-parse "$prev_tag" >/dev/null 2>&1; then
        prev_tag=""
    fi

    # Get commits since last version with full message
    # Format: hash|||FIELD|||subject|||FIELD|||body|||FIELD|||END
    # Using |||FIELD||| as delimiter to avoid conflicts with ||| in commit messages
    local commits
    if [ -n "$prev_tag" ]; then
        commits=$(git log --pretty=format:"%h|||FIELD|||%s|||FIELD|||%b|||FIELD|||END" "$prev_tag..HEAD" 2>/dev/null)
    else
        commits=$(git log --pretty=format:"%h|||FIELD|||%s|||FIELD|||%b|||FIELD|||END" 2>/dev/null)
    fi

    # Parse commits into categories with full messages
    declare -A feat_commits
    declare -A fix_commits
    declare -A docs_commits
    declare -A refactor_commits
    declare -A perf_commits
    declare -A test_commits
    declare -A other_commits

    local commit_buffer=""
    while IFS= read -r line; do
        if [[ $line == *"|||FIELD|||END" ]]; then
            # Process accumulated commit
            if [ -n "$commit_buffer" ]; then
                # Split on |||FIELD||| delimiter - extract hash first
                local hash="${commit_buffer%%|||FIELD|||*}"
                local rest="${commit_buffer#*|||FIELD|||}"
                # Now split rest to get subject and body
                local subject="${rest%%|||FIELD|||*}"
                local body="${rest#*|||FIELD|||}"

                # Filter out Co-Authored-By lines
                body=$(echo "$body" | grep -v "^Co-Authored-By: Claude Sonnet")

                # Skip chore commits
                if [[ ! $subject =~ ^chore(\(.*\))?: ]]; then
                    # Store subject and body together
                    local full_msg="$subject|||FIELD|||$body"

                    # Categorize by type
                    if [[ $subject =~ ^feat(\(.*\))?: ]]; then
                        feat_commits[$hash]="$full_msg"
                    elif [[ $subject =~ ^fix(\(.*\))?: ]]; then
                        fix_commits[$hash]="$full_msg"
                    elif [[ $subject =~ ^docs(\(.*\))?: ]]; then
                        docs_commits[$hash]="$full_msg"
                    elif [[ $subject =~ ^refactor(\(.*\))?: ]]; then
                        refactor_commits[$hash]="$full_msg"
                    elif [[ $subject =~ ^perf(\(.*\))?: ]]; then
                        perf_commits[$hash]="$full_msg"
                    elif [[ $subject =~ ^test(\(.*\))?: ]]; then
                        test_commits[$hash]="$full_msg"
                    else
                        other_commits[$hash]="$full_msg"
                    fi
                fi
            fi
            commit_buffer=""
        else
            commit_buffer+="$line"$'\n'
        fi
    done <<< "$commits"

    # Start building the release notes
    local notes=""
    notes+="# jsonquill v$new_version\n\n"
    notes+="**Release Date:** $date\n\n"

    # New Features section
    if [ ${#feat_commits[@]} -gt 0 ]; then
        notes+="## ðŸŽ‰ New Features\n\n"
        for hash in "${!feat_commits[@]}"; do
            local full_msg="${feat_commits[$hash]}"
            # Split on ||| delimiter using bash
            local subject="${full_msg%%|||FIELD|||*}"
            local body="${full_msg#*|||FIELD|||}"

            # Extract title (remove feat prefix and scope)
            local title=$(echo "$subject" | sed 's/^feat(\(.*\)): //' | sed 's/^feat: //')
            # Capitalize first letter
            title="$(echo ${title:0:1} | tr '[:lower:]' '[:upper:]')${title:1}"
            notes+="### $title\n\n"

            # Add body if it exists, otherwise add a placeholder
            if [ -n "$body" ]; then
                notes+="$body\n\n"
            else
                notes+="_No additional details provided._\n\n"
            fi
        done
    fi

    # Documentation section
    if [ ${#docs_commits[@]} -gt 0 ]; then
        notes+="## ðŸ“š Documentation\n\n"
        for hash in "${!docs_commits[@]}"; do
            local full_msg="${docs_commits[$hash]}"
            local subject="${full_msg%%|||*}"
            local desc=$(echo "$subject" | sed 's/^docs(\(.*\)): //' | sed 's/^docs: //')
            notes+="- $desc\n"
        done
        notes+="\n"
    fi

    # Testing section
    if [ ${#test_commits[@]} -gt 0 ]; then
        notes+="## ðŸ§ª Testing\n\n"
        for hash in "${!test_commits[@]}"; do
            local full_msg="${test_commits[$hash]}"
            local subject="${full_msg%%|||*}"
            local desc=$(echo "$subject" | sed 's/^test(\(.*\)): //' | sed 's/^test: //')
            notes+="- $desc\n"
        done
        notes+="\n"
    fi

    # Technical Details section
    if [ ${#refactor_commits[@]} -gt 0 ] || [ ${#perf_commits[@]} -gt 0 ]; then
        notes+="## ðŸ”§ Technical Details\n\n"
        for hash in "${!refactor_commits[@]}"; do
            local full_msg="${refactor_commits[$hash]}"
            local subject="${full_msg%%|||*}"
            local desc=$(echo "$subject" | sed 's/^refactor(\(.*\)): //' | sed 's/^refactor: //')
            notes+="- $desc\n"
        done
        for hash in "${!perf_commits[@]}"; do
            local full_msg="${perf_commits[$hash]}"
            local subject="${full_msg%%|||*}"
            local desc=$(echo "$subject" | sed 's/^perf(\(.*\)): //' | sed 's/^perf: //')
            notes+="- $desc\n"
        done
        notes+="\n"
    fi

    # Fixes section
    if [ ${#fix_commits[@]} -gt 0 ]; then
        notes+="## ðŸ› ï¸ Fixes\n\n"
        for hash in "${!fix_commits[@]}"; do
            local full_msg="${fix_commits[$hash]}"
            local subject="${full_msg%%|||*}"
            local desc=$(echo "$subject" | sed 's/^fix(\(.*\)): //' | sed 's/^fix: //')
            notes+="- $desc\n"
        done
        notes+="\n"
    fi

    # Other changes section
    if [ ${#other_commits[@]} -gt 0 ]; then
        notes+="## ðŸ“ Other Changes\n\n"
        for hash in "${!other_commits[@]}"; do
            local full_msg="${other_commits[$hash]}"
            local subject="${full_msg%%|||*}"
            notes+="- $subject\n"
        done
        notes+="\n"
    fi

    # Full changelog link
    notes+="---\n\n"
    notes+="**Full Changelog**: https://github.com/joeygibson/jsonquill/compare/v$current_version...v$new_version\n"

    echo -e "$notes"
}

# Function to update CHANGELOG.md
update_changelog() {
    local new_version=$1
    local current_version=$2
    local date=$(date +%Y-%m-%d)

    if [ ! -f CHANGELOG.md ]; then
        echo -e "${YELLOW}Warning: CHANGELOG.md not found, skipping changelog update${NC}"
        return
    fi

    # Generate release notes from git commits
    local release_notes=$(generate_release_notes "$current_version")

    # Create the new version entry in a temp file
    local temp_entry=$(mktemp)
    echo "## [$new_version] - $date" > "$temp_entry"
    echo "" >> "$temp_entry"
    echo -e "$release_notes" >> "$temp_entry"

    # Find the first ## header (should be the previous version)
    # Insert the new entry before it
    awk '
        !inserted && /^## \[/ {
            system("cat '"$temp_entry"'")
            inserted = 1
        }
        { print }
    ' CHANGELOG.md > CHANGELOG.md.tmp

    rm "$temp_entry"
    mv CHANGELOG.md.tmp CHANGELOG.md

    # Update the version comparison links at the bottom
    # Add new link and update the previous version link
    if grep -q "^\[$current_version\]:" CHANGELOG.md; then
        # Find what version comes before current_version to update the link
        local prev_version=$(grep "^\[$current_version\]:" CHANGELOG.md | sed 's/.*v\([0-9.]*\)\.\.\.v.*/\1/')

        # Update the current version link to have the new version as its end point
        sed -i.bak "s|^\[$current_version\]:.*|\[$current_version\]: https://github.com/yourusername/jsonquill/compare/v${prev_version}...v$current_version|" CHANGELOG.md
        rm CHANGELOG.md.bak

        # Add the new version link at the end (before the last line if it exists)
        echo "[$new_version]: https://github.com/yourusername/jsonquill/compare/v$current_version...v$new_version" >> CHANGELOG.md
    fi

    echo -e "${GREEN}Updated CHANGELOG.md with v$new_version entry${NC}"
    echo -e "${YELLOW}Generated release notes from git commits${NC}"
}

# Main script logic
if [ $# -eq 0 ]; then
    # No arguments: print current version
    current_version=$(get_version)
    echo "$current_version"
elif [ $# -eq 1 ]; then
    # One argument: update version
    new_version=$1

    # Validate version format
    validate_version "$new_version"

    # Get current version
    current_version=$(get_version)

    if [ "$current_version" = "$new_version" ]; then
        echo -e "${YELLOW}Version is already $new_version${NC}"
        exit 0
    fi

    echo -e "${GREEN}Updating version: $current_version â†’ $new_version${NC}"

    # Update Cargo.toml
    update_version "$new_version"

    # Update CHANGELOG.md
    update_changelog "$new_version" "$current_version"

    # Generate GitHub release notes
    release_notes_file="release-notes-v$new_version.md"
    generate_github_release_notes "$new_version" "$current_version" > "$release_notes_file"
    echo -e "${GREEN}Generated GitHub release notes: $release_notes_file${NC}"

    # Ask if user wants to review/edit CHANGELOG.md
    if [ -f CHANGELOG.md ]; then
        echo ""
        echo -e "${YELLOW}Review/edit the generated CHANGELOG.md? [y/N]${NC}"
        read -r response
        if [[ "$response" =~ ^[Yy]$ ]]; then
            ${EDITOR:-vi} CHANGELOG.md
        fi
    fi

    # Run cargo build to update Cargo.lock
    echo -e "${GREEN}Running cargo build...${NC}"
    cargo build

    # Commit the changes
    echo -e "${GREEN}Committing version bump...${NC}"
    git add Cargo.toml Cargo.lock CHANGELOG.md
    git commit -m "chore: bump version to $new_version"

    # Create git tag
    tag_name="v$new_version"
    echo -e "${GREEN}Creating git tag: $tag_name${NC}"
    git tag "$tag_name"

    # Print push command (but don't execute it)
    echo ""
    echo -e "${YELLOW}Version updated successfully!${NC}"
    echo -e "${YELLOW}To push changes and tag, run:${NC}"
    echo -e "${GREEN}git push && git push origin $tag_name${NC}"
    echo ""
    echo -e "${YELLOW}GitHub release notes saved to: ${GREEN}$release_notes_file${NC}"
    echo -e "${YELLOW}Edit the file to add detailed descriptions, then paste into GitHub release.${NC}"
else
    echo -e "${RED}Error: Too many arguments${NC}" >&2
    echo "Usage:"
    echo "  ver           # Print current version"
    echo "  ver X.Y.Z     # Update to version X.Y.Z"
    exit 1
fi
